
function G_mu = G_function(I_loss, family, y, mu, results, ...
    options, index_robust_c, choice_rho_function, c_tune_constant)

%--------------------------------------------------------------------------
% Name    : G_function.m
% Function: explicit formula for G(\mu)
%           = \int_y^\mu G_1'(s) \{q''(s) \sqrt(V(s))\} ds
% Called  : deri_1_G.m
%--------------------------------------------------------------------------
% <Input>
% index_robust_c:  0: \psi(r)  =  r;
%                  1: \psi(r) \ne r;
%choice_rho_function: 1 Huber \rho function; 2 Tukey biweight function
% c_tune_constant: constant used in \psi(r)
%--------------------------------------------------------------------------
% <Output>
%--------------------------------------------------------------------------

n_obs = size(mu, 1);

%--------------------- for classical-BD ----------------------

if index_robust_c == 0 || c_tune_constant == inf  % \psi(r) = r

    G_mu = zeros(n_obs, 1);
    return
end

%---------------------- for robust-BD ------------------------

% index_robust_c == 1 && c_tune_constant ~= inf  % \psi(r) \ne r

if     family == 0     % Gaussian responses

    if (I_loss == 1 || I_loss == 3) % deviance, quadratic
        G_mu = 0;
    end

elseif family == 1     % Bernoulli responses

    one_minus_mu = 1 - mu;
    V_original = mu.*one_minus_mu;
    sqrt_V_original = sqrt(V_original);

    c_square = c_tune_constant^2;
    C_1 = 1/(1 + c_square); C_2 = 1 - C_1;

    C_2_square = C_2^2;

    if     c_tune_constant < 1
        LL_G = y;
        UL = mu;            % upper limit in the intergration

        G_mu = zeros(n_obs, 1);
        for i = 1:n_obs
            G_mu(i) = integral( ...
                @(x) deri_1_G(family, I_loss, x, index_robust_c, ...
                choice_rho_function, c_tune_constant, [], results, options), ...
                LL_G(i), UL(i));       % G(\mu)
        end

    elseif c_tune_constant >= 1

        if     I_loss == 1    % deviance loss
            if     strcmpi(choice_rho_function, 'Huber') % deviance loss
                asin_sqrt_mu = asin(sqrt(mu));
                asin_sqrt_C_1 = asin(sqrt(C_1));
                asin_sqrt_C_2 = asin(sqrt(C_2));
                two_c = 2*c_tune_constant;

                G_mu = ...
                    + ( - 2*one_minus_mu ...
                    - two_c*(asin_sqrt_mu - asin_sqrt_C_1 - sqrt_V_original) )...
                    .*(0 <= mu & mu <= C_1) ...
                    + ( - 2*mu ...
                    + two_c*(asin_sqrt_mu - asin_sqrt_C_2 + sqrt_V_original) )...
                    .*(C_2 <= mu & mu <= 1);

            elseif strcmpi(choice_rho_function, 'Tukey_biweight') % deviance loss
                log_C_1 = log(C_1);
                c_quartic = c_tune_constant^4;

                G_mu = zeros(n_obs, 1);
                G_mu(0 <= mu & mu <= C_1) = ...
                    + 2*( ...
                    (mu(0 <= mu & mu <= C_1))/C_2_square ...
                    + 2/(c_square*C_2)*log(one_minus_mu(0 <= mu & mu <= C_1)) ...
                    + (1/c_quartic)./(one_minus_mu(0 <= mu & mu <= C_1)) ...
                    ) ...
                    - 2*( ...
                    C_1/C_2_square ...
                    - 2/(c_square*C_2)*log_C_1 ...
                    - (1/c_quartic)*(1/C_1) ...
                    );
                G_mu(C_1 < mu & mu < C_2) = ...
                    + 2*( ...
                    (mu(C_1 < mu & mu < C_2))/C_2_square ...
                    + 2/(c_square*C_2)*log(one_minus_mu(C_1 < mu & mu < C_2)) ...
                    + (1/c_quartic)./(one_minus_mu(C_1 < mu & mu < C_2)) ...
                    ) ...
                    - 2*( ...
                    (mu(C_1 < mu & mu < C_2))/C_2_square ...
                    - 2/(c_square*C_2)*log(mu(C_1 < mu & mu < C_2)) ...
                    - (1/c_quartic)./mu(C_1 < mu & mu < C_2) ...
                    );
                G_mu(C_2 <= mu & mu <= 1) = ...
                    + 2*( ...
                    C_2/C_2_square ...
                    + 2/(c_square*C_2)*log_C_1 ...
                    + (1/c_quartic)*(1/C_1) ...
                    ) ...
                    - 2*( ...
                    (mu(C_2 <= mu & mu <= 1))/C_2_square ...
                    - 2/(c_square*C_2)*log(mu(C_2 <= mu & mu <= 1)) ...
                    - (1/c_quartic)./mu(C_2 <= mu & mu <= 1) ...
                    );
            end

        elseif I_loss == 2   % exponential loss
            if     strcmpi(choice_rho_function, 'Huber') % exponential loss
                asin_sqrt_mu  = asin(sqrt(mu));
                asin_sqrt_C_1 = asin(sqrt(C_1));
                asin_sqrt_C_2 = asin(sqrt(C_2));
                log_C_2 = log(C_2);
                half_c = c_tune_constant/2;

                G_mu = zeros(n_obs, 1);
                G_mu(0 <= mu & mu <= C_1) = ...
                    + ( asin_sqrt_mu(0 <= mu & mu <= C_1) - asin_sqrt_C_1 ) ...
                    + half_c*( log( one_minus_mu(0 <= mu & mu <= C_1) ) - log_C_2 );
                G_mu(C_1 < mu & mu < C_2) = 0;
                G_mu(C_2 <= mu & mu <= 1) = ...
                    - ( asin_sqrt_mu(C_2 <= mu & mu <= 1) - asin_sqrt_C_2 ) ...
                    + half_c*( log(           mu(C_2 <= mu & mu <= 1) ) - log_C_2 );

            elseif strcmpi(choice_rho_function, 'Tukey_biweight') % exponential loss
                asin_sqrt_mu = asin(sqrt(mu));
                asin_sqrt_C_1 = asin(sqrt(C_1));
                asin_sqrt_C_2 = asin(sqrt(C_2));
                c_quartic = c_tune_constant^4;

                G_mu = zeros(n_obs, 1);
                G_mu(0 <= mu & mu <= C_1) = ...
                    + asin_sqrt_mu(0 <= mu & mu <= C_1) ...
                    - (1/c_square)*( 2*sqrt( mu(0 <= mu & mu <= C_1) ...
                    ./one_minus_mu(0 <= mu & mu <= C_1) ) ...
                    - 2*asin_sqrt_mu(0 <= mu & mu <= C_1) ) ...
                    + 1/(2*c_quartic)*( -2/3*sqrt( mu(0 <= mu & mu <= C_1) ...
                    ./one_minus_mu(0 <= mu & mu <= C_1) ) ...
                    .*(2*mu(0 <= mu & mu <= C_1) - 3) ...
                    ./one_minus_mu(0 <= mu & mu <= C_1) ...
                    - 4*sqrt( mu(0 <= mu & mu <= C_1) ...
                    ./one_minus_mu(0 <= mu & mu <= C_1) ) ...
                    + 2*asin_sqrt_mu(0 <= mu & mu <= C_1) ) ...
                    - asin_sqrt_C_1 ...
                    + (1/c_square)*( -2*sqrt(C_2/C_1) - 2*asin_sqrt_C_1 ) ...
                    - 1/(2*c_quartic)*( -2/3*sqrt(C_2/C_1)*(1 + 2*C_1)/C_1 ...
                    + 4*sqrt(C_2/C_1) + 2*asin_sqrt_C_1 );
                G_mu(C_1 < mu & mu < C_2) = ...
                    + asin_sqrt_mu(C_1 < mu & mu < C_2) ...
                    - (1/c_square)*( 2*sqrt( mu(C_1 < mu & mu < C_2) ...
                    ./one_minus_mu(C_1 < mu & mu < C_2) ) ...
                    - 2*asin_sqrt_mu(C_1 < mu & mu < C_2) ) ...
                    + 1/(2*c_quartic)*( -2/3*sqrt( mu(C_1 < mu & mu < C_2) ...
                    ./one_minus_mu(C_1 < mu & mu < C_2) ) ...
                    .*(2*mu(C_1 < mu & mu < C_2) - 3) ...
                    ./one_minus_mu(C_1 < mu & mu < C_2) ...
                    - 4*sqrt( mu(C_1 < mu & mu < C_2) ...
                    ./one_minus_mu(C_1 < mu & mu < C_2) ) ...
                    + 2*asin_sqrt_mu(C_1 < mu & mu < C_2) ) ...
                    - asin_sqrt_mu(C_1 < mu & mu < C_2) ...
                    + (1/c_square)*( -2*sqrt( one_minus_mu(C_1 < mu & mu < C_2) ...
                    ./mu(C_1 < mu & mu < C_2) ) ...
                    - 2*asin_sqrt_mu(C_1 < mu & mu < C_2) ) ...
                    - 1/(2*c_quartic)*( -2/3*sqrt( one_minus_mu(C_1 < mu & mu < C_2) ...
                    ./mu(C_1 < mu & mu < C_2) ) ...
                    .*(1 + 2*mu(C_1 < mu & mu < C_2)) ...
                    ./mu(C_1 < mu & mu < C_2) ...
                    + 4*sqrt( one_minus_mu(C_1 < mu & mu < C_2) ...
                    ./mu(C_1 < mu & mu < C_2) )...
                    + 2*asin_sqrt_mu(C_1 < mu & mu < C_2) );
                G_mu(C_2 <= mu & mu <= 1) = ...
                    + asin_sqrt_C_2 ...
                    - (1/c_square)*( 2*sqrt(C_2/C_1) - 2*asin_sqrt_C_2 ) ...
                    + 1/(2*c_quartic)*( -2/3*sqrt(C_2/C_1)*(2*C_2 - 3)/(1-C_2) ...
                    - 4*sqrt(C_2/C_1) + 2*asin_sqrt_C_2 ) ...
                    - asin_sqrt_mu(C_2 <= mu & mu <= 1) ...
                    + (1/c_square)*( -2*sqrt( one_minus_mu(C_2 <= mu & mu <= 1) ...
                    ./mu(C_2 <= mu & mu <= 1) ) ...
                    - 2*asin_sqrt_mu(C_2 <= mu & mu <= 1) ) ...
                    - 1/(2*c_quartic)*( -2/3*sqrt( one_minus_mu(C_2 <= mu & mu <= 1) ...
                    ./mu(C_2 <= mu & mu <= 1) ) ...
                    .*(1 + 2*mu(C_2 <= mu & mu <= 1)) ...
                    ./mu(C_2 <= mu & mu <= 1) ...
                    + 4*sqrt( one_minus_mu(C_2 <= mu & mu <= 1) ...
                    ./mu(C_2 <= mu & mu <= 1) ) ...
                    + 2*asin_sqrt_mu(C_2 <= mu & mu <= 1) );
            end
        end
    end

elseif family == 12    % Binomial responses

    if I_loss == 1 % deviance loss
        y_Bin = y(:, 1);
        LL_G = y_Bin;
        UL = mu;            % upper limit in the intergration

        G_mu = zeros(n_obs, 1);
        for i = 1:n_obs
            G_mu(i) = quad( ...
                @(x) deri_1_G(family, I_loss, x, index_robust_c, ...
                choice_rho_function, c_tune_constant, y(i, :), results, options), ...
                LL_G(i), UL(i));       % G(\mu)
        end
    end

elseif family == 21    % Poisson responses

    if I_loss == 211  % V(x)=phi x, (negative) quasi-likelihood
        LL_G = y;
        UL = mu;            % upper limit in the intergration

        G_mu = zeros(n_obs, 1);
        for i = 1:n_obs
            G_mu(i) = quad( ...
                @(x) deri_1_G(family, I_loss, x, index_robust_c, ...
                choice_rho_function, c_tune_constant, [], results, options), ...
                LL_G(i), UL(i));       % G(\mu)
            %G_mu(i) = integral( ...
            %    @(x) deri_1_G(family, I_loss, x, index_robust_c, ...
            %    choice_rho_function, c_tune_constant, [], results, options), ...
            %    LL_G(i), UL(i));       % G(\mu)
        end
    end
end

if any(isempty(G_mu)) == 1
    disp(' !!!G_function.m: some estimate of G_mu = [ ]!!!');
end

if any(isnan(G_mu)) == 1
    disp(' !!!G_function.m: some estimate of G_mu = NaN!!!');
end

if any(isinf(G_mu)) == 1
    disp(' !!!G_function.m: some estimate of G_mu = Inf!!!');
end
