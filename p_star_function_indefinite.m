
function f = p_star_function_indefinite(I_loss, family, theta, y, mu, ...
    results, options, index_robust_c, choice_rho_function, c_tune_constant)

%--------------------------------------------------------------------------
% Name    : p_star_function_indefinite.m
% Function: explicit formula for
%           \int_{-\infty}^mu \psi(r(y,s)) \{q''(s) \sqrt(V(s))\} ds
% Called  : deri_1_p_star.m
%--------------------------------------------------------------------------
% <Input>
% index_robust_c:  0: \psi(r)  =  r;
%                  1: \psi(r) \ne r;
%choice_rho_function: 1 Huber \rho function; 2 Tukey biweight function
% c_tune_constant: constant used in \psi(r)
%--------------------------------------------------------------------------
% <Output>
%--------------------------------------------------------------------------

%--------------------- for classical-BD ----------------------

if index_robust_c == 0 || c_tune_constant == inf  % \psi(r) = r

    f = true_qq(I_loss, family, link, theta, y, deri, options);
    return
end

%---------------------- for robust-BD ------------------------

% index_robust_c == 1 && c_tune_constant ~= inf  % \psi(r) \ne r

n_obs = size(mu, 1);

if     family == 0     % Gaussian responses
    if (I_loss == 1 || I_loss == 3) % deviance, quadratic
        V_original = results.V_original;  % V(u) = \sigma^2
        sqrt_V_original = sqrt(V_original);

        r_y_mu = (y - mu)./sqrt_V_original;

        rho_c_r = robust_rho_function(r_y_mu, index_robust_c, ...
            choice_rho_function, c_tune_constant, 0);

        p_star_y_mu = rho_c_r*(2*V_original);
        %p_star_y_mu = rho_c_r;
    end

elseif family == 1     % Bernoulli responses

    c_square = c_tune_constant^2;
    C_1 = 1/(1 + c_square); C_2 = 1 - C_1;

    one_minus_mu = 1 - mu;
    one_minus_y = 1 - y;

    if     c_tune_constant < 1
        LL = 0.1;          % lower limit in the intergration
        UL = mu;           % upper limit in the intergration

        p_star_y_mu = zeros(n_obs, 1);
        for i = 1:n_obs
            p_star_y_mu(i) = integral( ...
                @(x) deri_1_p_star(family, I_loss, x, index_robust_c, ...
                choice_rho_function, c_tune_constant, y(i, :), results, ...
                options), LL, UL(i));  % p^*(y, mu)
        end

    elseif c_tune_constant >= 1
        if     I_loss == 1    % deviance loss
            if     strcmpi(choice_rho_function, 'Huber') % deviance loss
                asin_sqrt_mu = asin(sqrt(mu));
                log_C_1 = log(C_1);
                asin_sqrt_C_1 = asin(sqrt(C_1));
                asin_sqrt_C_2 = asin(sqrt(C_2));
                four_c = 4*c_tune_constant;

                %----------------------------------------------------------

                p_star_y_mu = zeros(n_obs, 1);
                p_star_y_mu(0 <= mu & mu <= C_1) = ...
                    - 2*log( one_minus_mu(0 <= mu & mu <= C_1) ) ...
                    .*one_minus_y(0 <= mu & mu <= C_1) ...
                    - ( four_c*...
                    (asin_sqrt_mu(0 <= mu & mu <= C_1) - asin_sqrt_C_1) ...
                    + 2*log_C_1 ) ...
                    .*y          (0 <= mu & mu <= C_1);
                p_star_y_mu(C_1 < mu & mu < C_2) = ...
                    - 2*log( one_minus_mu(C_1 < mu & mu < C_2) ) ...
                    .*one_minus_y(C_1 < mu & mu < C_2) ...
                    - 2*log(           mu(C_1 < mu & mu < C_2) ) ...
                    .*y          (C_1 < mu & mu < C_2);
                p_star_y_mu(C_2 <= mu & mu <= 1) = ...
                    - 2*log( mu(C_2 <= mu & mu <= 1) ) ...
                    .*y          (C_2 <= mu & mu <= 1) ...
                    + ( four_c*...
                    (asin_sqrt_mu(C_2 <= mu & mu <= 1) - asin_sqrt_C_2) ...
                    - 2*log_C_1 ) ...
                    .*one_minus_y(C_2 <= mu & mu <= 1);

            elseif strcmpi(choice_rho_function, 'Tukey_biweight') % deviance loss
                log_C_1 = log(C_1);
                c_quartic = c_tune_constant^4;

                C_1_square = C_1^2; C_2_square = C_2^2;

                %----------------------------------------------------------
                p_star_y_mu = zeros(n_obs, 1);
                p_star_y_mu(0 <= mu & mu <= C_1) = ...
                    + 2*( ...
                    - (1/C_2_square)*( log(one_minus_mu(0 <= mu & mu <= C_1)) - log_C_1 ) ...
                    - (2/c_square)  *( 1./one_minus_mu(0 <= mu & mu <= C_1) - 1/C_1 ) ...
                    + (1/c_quartic) *( (2*mu(0 <= mu & mu <= C_1) - 3/2) ...
                    ./(one_minus_mu(0 <= mu & mu <= C_1).^2) ...
                    - (2*C_2 - 3/2)/C_1_square ) ...
                    ).*one_minus_y(0 <= mu & mu <= C_1);
                p_star_y_mu(C_1 < mu & mu < C_2) = ...
                    + 2*( ...
                    - (1/C_2_square)*( log(one_minus_mu(C_1 < mu & mu < C_2)) - log_C_1 ) ...
                    - (2/c_square)  *( 1./one_minus_mu(C_1 < mu & mu < C_2) - 1/C_1 ) ...
                    + (1/c_quartic) *( (2*mu(C_1 < mu & mu < C_2) - 3/2) ...
                    ./(one_minus_mu(C_1 < mu & mu < C_2).^2) ...
                    - (2*C_2 - 3/2)/C_1_square ) ...
                    ).*one_minus_y(C_1 < mu & mu < C_2) ...
                    - 2*( ...
                    + (1/C_2_square)*( log(mu(C_1 < mu & mu < C_2)) - log_C_1 ) ...
                    + (2/c_square)  *( 1./mu(C_1 < mu & mu < C_2) - 1/C_1 ) ...
                    + (1/c_quartic) *( (2*mu(C_1 < mu & mu < C_2) - 1/2) ...
                    ./(mu(C_1 < mu & mu < C_2).^2) ...
                    - (2*C_1 - 1/2)/C_1_square ) ...
                    ).*y(C_1 < mu & mu < C_2);
                p_star_y_mu(C_2 <= mu & mu <= 1) = ...
                    - 2*( ...
                    + (1/C_2_square)*( log(mu(C_2 <= mu & mu <= 1)) - log_C_1 ) ...
                    + (2/c_square)  *( 1./mu(C_2 <= mu & mu <= 1) - 1/C_1 ) ...
                    + (1/c_quartic) *( (2*mu(C_2 <= mu & mu <= 1) - 1/2) ...
                    ./(mu(C_2 <= mu & mu <= 1).^2) ...
                    - (2*C_1 - 1/2)/C_1_square ) ...
                    ).*y(C_2 <= mu & mu <= 1);
            end

        elseif I_loss == 2    % exponential loss
            if     strcmpi(choice_rho_function, 'Huber') % exponential loss
                log_c_tune_constant = log(c_tune_constant);

                half_c = c_tune_constant/2;

                %----------------------------------------------------------

                p_star_y_mu = zeros(n_obs, 1);
                p_star_y_mu(0 <= mu & mu <= C_1) = ...
                    sqrt( mu(0 <= mu & mu <= C_1)./one_minus_mu(0 <= mu & mu <= C_1) ) ...
                    .*one_minus_y(0 <= mu & mu <= C_1) ...
                    + ( - half_c*theta(0 <= mu & mu <= C_1) ...
                    - c_tune_constant*log_c_tune_constant + c_tune_constant ) ...
                    .*y(0 <= mu & mu <= C_1);
                p_star_y_mu(C_1 < mu & mu < C_2) = ...
                    sqrt( mu(C_1 < mu & mu < C_2)./one_minus_mu(C_1 < mu & mu < C_2) ) ...
                    .*one_minus_y(C_1 < mu & mu < C_2) ...
                    + ...
                    sqrt( one_minus_mu(C_1 < mu & mu < C_2)./mu(C_1 < mu & mu < C_2) ) ...
                    .*y(C_1 < mu & mu < C_2);
                p_star_y_mu(C_2 <= mu & mu <= 1) = ...
                    sqrt( one_minus_mu(C_2 <= mu & mu <= 1)./mu(C_2 <= mu & mu <= 1) ) ...
                    .*y(C_2 <= mu & mu <= 1) ...
                    + ( half_c*theta(C_2 <= mu & mu <= 1) ...
                    - c_tune_constant*log_c_tune_constant + c_tune_constant ) ...
                    .*one_minus_y(C_2 <= mu & mu <= 1);

            elseif strcmpi(choice_rho_function, 'Tukey_biweight') % exponential loss
                c_quartic = c_tune_constant^4;

                %----------------------------------------------------------

                p_star_y_mu = zeros(n_obs, 1);
                p_star_y_mu(0 <= mu & mu <= C_1) = ...
                    ( ...
                    sqrt( mu(0 <= mu & mu <= C_1) ...
                    ./one_minus_mu(0 <= mu & mu <= C_1) ) ...
                    .*( 1 - 2/(3*c_square)*mu(0 <= mu & mu <= C_1) ...
                    ./one_minus_mu(0 <= mu & mu <= C_1) ...
                    + 1/(5*c_quartic)*(mu(0 <= mu & mu <= C_1).^2) ...
                    ./(one_minus_mu(0 <= mu & mu <= C_1).^2) ) ...
                    - ...
                    sqrt(C_2/C_1) ...
                    .*( 1 - 2/(3*c_square)*(C_2/C_1) ...
                    + 1/(5*c_quartic)*(C_2/C_1)^2 ) ...
                    ).*one_minus_y(0 <= mu & mu <= C_1);
                p_star_y_mu(C_1 < mu & mu < C_2) = ...
                    ( ...
                    sqrt( mu(C_1 < mu & mu < C_2) ...
                    ./one_minus_mu(C_1 < mu & mu < C_2) ) ...
                    .*( 1 - 2/(3*c_square)*mu(C_1 < mu & mu < C_2) ...
                    ./one_minus_mu(C_1 < mu & mu < C_2) ...
                    + 1/(5*c_quartic)*(mu(C_1 < mu & mu < C_2).^2) ...
                    ./(one_minus_mu(C_1 < mu & mu < C_2).^2) ) ...
                    - ...
                    sqrt(C_2/C_1)...
                    .*( 1 - 2/(3*c_square)*(C_2/C_1) ...
                    + 1/(5*c_quartic)*(C_2/C_1)^2 ) ...
                    ).*one_minus_y(C_1 < mu & mu < C_2) ...
                    + ...
                    ( ...
                    sqrt( one_minus_mu(C_1 < mu & mu < C_2) ...
                    ./mu(C_1 < mu & mu < C_2) ) ...
                    .*( 1 - 2/(3*c_square)*one_minus_mu(C_1 < mu & mu < C_2) ...
                    ./mu(C_1 < mu & mu < C_2) ...
                    + 1/(5*c_quartic)*(one_minus_mu(C_1 < mu & mu < C_2).^2) ...
                    ./(mu(C_1 < mu & mu < C_2).^2) ) ...
                    - ...
                    sqrt(C_2/C_1) ...
                    .*( 1 - 2/(3*c_square)*(C_2/C_1) ...
                    + 1/(5*c_quartic)*(C_2/C_1)^2 ) ...
                    ).*y(C_1 < mu & mu < C_2);
                p_star_y_mu(C_2 <= mu & mu <= 1) = ...
                    ( ...
                    sqrt( one_minus_mu(C_2 <= mu & mu <= 1) ...
                    ./mu(C_2 <= mu & mu <= 1) ) ...
                    .*( 1 - 2/(3*c_square)*one_minus_mu(C_2 <= mu & mu <= 1) ...
                    ./mu(C_2 <= mu & mu <= 1) ...
                    + 1/(5*c_quartic)*(one_minus_mu(C_2 <= mu & mu <= 1).^2) ...
                    ./(mu(C_2 <= mu & mu <= 1).^2) ) ...
                    - ...
                    sqrt(C_2/C_1)...
                    .*( 1 - 2/(3*c_square)*(C_2/C_1) ...
                    + 1/(5*c_quartic)*(C_2/C_1)^2 ) ...
                    ).*y(C_2 <= mu & mu <= 1);
            end
        end
    end

elseif family == 12     % Binomial responses
    y_Bin = y(:, 1);
    N_Bin = y(:, 2);

    c_square = c_tune_constant^2;

    if I_loss == 1 % deviance loss
        if     strcmpi(choice_rho_function, 'Huber') % deviance loss
            N_minus_y = N_Bin - y_Bin;  % N - y

            mu_1 = ( (2*y_Bin + c_square).*N_Bin - c_tune_constant ...
                *sqrt( N_Bin.*( 4*y_Bin.*N_minus_y + c_square*N_Bin ) ) ) ...
                ./( 2*(N_Bin + c_square) );
            mu_2 = ( (2*y_Bin + c_square).*N_Bin + c_tune_constant ...
                *sqrt( N_Bin.*( 4*y_Bin.*N_minus_y + c_square*N_Bin ) ) ) ...
                ./( 2*(N_Bin + c_square) );

            %----------------------------------------------------------

            y_log_mu_1 = zeros(n_obs, 1);  % y*log(mu_1(y))
            %y_log_mu_1(y == 0) = 0;
            y_log_mu_1(y_Bin > 0) = ...
                y_Bin(y_Bin > 0).*log( mu_1(y_Bin > 0) );

            N_minus_mu_2 = N_Bin - mu_2;   % N - mu_2

            N_minus_y_log_N_minus_mu_2 = zeros(n_obs, 1);
            % (N - y)*log(N - mu_2(y))
            % N_minus_y_log_N_minus_mu_2(y == N) = 0;
            N_minus_y_log_N_minus_mu_2(y_Bin < N_Bin) = ...
                N_minus_y(y_Bin < N_Bin).*log( N_minus_mu_2(y_Bin < N_Bin) );

            N_minus_mu   = N_Bin - mu;     % N - mu
            N_minus_mu_1 = N_Bin - mu_1;   % N - mu_1

            sqrt_N_Bin = sqrt(N_Bin);
            asin_mu = asin(sqrt(mu  ./N_Bin));
            asin_1  = asin(sqrt(mu_1./N_Bin));
            asin_2  = asin(sqrt(mu_2./N_Bin));

            if     mu ~= y_Bin
                p_star_y_mu = zeros(n_obs, 1);
                p_star_y_mu(mu >= mu_2) = ...
                    + 4*c_tune_constant*sqrt_N_Bin(mu >= mu_2) ...
                    .*( asin_mu(mu >= mu_2) - asin_2(mu >= mu_2) ) ...
                    - 2*( y_Bin(mu >= mu_2).*log(mu_2(mu >= mu_2)) ...
                    + N_minus_y_log_N_minus_mu_2(mu >= mu_2) );
                p_star_y_mu(mu_1 < mu & mu < mu_2) =  ...
                    -2*(  y_Bin(mu_1 < mu & mu < mu_2) ...
                    .*log(mu(mu_1 < mu & mu < mu_2)) ...
                    + N_minus_y(mu_1 < mu & mu < mu_2) ...
                    .*log( N_minus_mu(mu_1 < mu & mu < mu_2) ) );
                p_star_y_mu(mu <= mu_1) = ...
                    - 4*c_tune_constant*sqrt_N_Bin(mu <= mu_1) ...
                    .*( asin_mu(mu <= mu_1) - asin_1(mu <= mu_1) ) ...
                    - 2*( y_log_mu_1(mu <= mu_1) ...
                    + N_minus_y(mu <= mu_1) ...
                    .*log( N_minus_mu_1(mu <= mu_1) ) );

            elseif mu == y_Bin
                N_log_N = N_Bin.*log(N_Bin);   % N log(N)

                p_star_y_mu = zeros(n_obs, 1);
                p_star_y_mu(y_Bin == 0    ) = -2*N_log_N(y_Bin == 0    );
                p_star_y_mu(y_Bin == N_Bin) = -2*N_log_N(y_Bin == N_Bin);
                p_star_y_mu(0 < y_Bin & y_Bin < N_Bin) = ...
                    - 2*( ...
                    + y_Bin    (0 < y_Bin & y_Bin < N_Bin) ...
                    .*log( y_Bin    (0 < y_Bin & y_Bin < N_Bin) ) ...
                    + N_minus_y(0 < y_Bin & y_Bin < N_Bin) ...
                    .*log( N_minus_y(0 < y_Bin & y_Bin < N_Bin) ) ...
                    );
                % -2\{y log(y) + (N - y) log(N - y)\}
            end

        elseif strcmpi(choice_rho_function, 'Tukey_biweight') % deviance loss
            LL = 0.1;          % lower limit in the intergration
            UL = mu;           % upper limit in the intergration

            p_star_y_mu = zeros(n_obs, 1);
            for i = 1:n_obs
                p_star_y_mu(i) = integral( ...
                    @(x) deri_1_p_star(family, I_loss, x, index_robust_c, ...
                    choice_rho_function, c_tune_constant, y(i, :), results, ...
                    options), LL, UL(i));  % p^*(y, mu)
            end
        end
    end

elseif family == 21     % Poisson responses
    if I_loss == 211  % V(x)=phi x, (negative) quasi-likelihood
        Poisson_phi = results.Poisson_phi;

        sqrt_Poisson_phi = sqrt(Poisson_phi);
        V_original = Poisson_phi*mu;  % V(u) = \phi u
        sqrt_V_original = sqrt(V_original);

        c_square = c_tune_constant^2;

        if     strcmpi(choice_rho_function, 'Huber') % quasi-likelihood
            mu_1 = ( (2*y + Poisson_phi*c_square) ...
                - sqrt_Poisson_phi*c_tune_constant ...
                *sqrt(4*y + Poisson_phi*c_square) )/2;
            mu_2 = ( (2*y + Poisson_phi*c_square) ...
                + sqrt_Poisson_phi*c_tune_constant ...
                *sqrt(4*y + Poisson_phi*c_square) )/2;

            %----------------------------------------------------------

            if     mu ~= y
                sqrt_V_mu_1 = sqrt(Poisson_phi*mu_1);
                sqrt_V_mu_2 = sqrt(Poisson_phi*mu_2);

                y_log_mu_1 = zeros(n_obs, 1);  % y*log(mu_1(y))
                %y_log_mu_1(y == 0) = 0;
                y_log_mu_1(y  > 0) = y(y > 0).*log(mu_1(y > 0));

                p_star_y_mu = zeros(n_obs, 1);
                p_star_y_mu(mu >= mu_2) = ...
                    + 2*c_tune_constant*( sqrt_V_original(mu >= mu_2) ...
                    - sqrt_V_mu_2(mu >= mu_2) ) ...
                    - ( y(mu >= mu_2).*log(mu_2(mu >= mu_2)) - mu_2(mu >= mu_2) );
                p_star_y_mu(mu_1 < mu & mu < mu_2) = - ( ...
                    y(mu_1 < mu & mu < mu_2).*theta(mu_1 < mu & mu < mu_2) ...
                    - mu(mu_1 < mu & mu < mu_2) );
                p_star_y_mu(mu <= mu_1) = ...
                    - 2*c_tune_constant*( sqrt_V_original(mu <= mu_1) ...
                    - sqrt_V_mu_1(mu <= mu_1) ) ...
                    - ( y_log_mu_1(mu <= mu_1) - mu_1(mu <= mu_1) );

            elseif mu == y
                y_log_y = zeros(n_obs, 1);  % y*log(y)
                %y_log_y(y == 0) = 0;
                y_log_y(y > 0) = y(y > 0).*log(y(y > 0));

                p_star_y_mu = -(y_log_y - y);
            end

        elseif strcmpi(choice_rho_function, 'Tukey_biweight') % quasi-likelihood
            LL = 0.1;          % lower limit in the intergration
            UL = mu;           % upper limit in the intergration

            p_star_y_mu = zeros(n_obs, 1);
            for i = 1:n_obs
                p_star_y_mu(i) = integral( ...
                    @(x) deri_1_p_star(family, I_loss, x, index_robust_c, ...
                    choice_rho_function, c_tune_constant, y(i, :), results, ...
                    options), LL, UL(i));  % p^*(y, mu)
            end
        end
    end
end

f = p_star_y_mu;

if any(isempty(f)) == 1
    disp(' !!!p_star_function_indefinite.m: some estimate of f = [ ]!!!');
end

if any(isnan(f)) == 1
    disp(' !!!p_star_function_indefinite.m: some estimate of f = NaN!!!');
end

if any(isinf(f)) == 1
    disp(' !!!p_star_function_indefinite.m: some estimate of f = Inf!!!');
end
